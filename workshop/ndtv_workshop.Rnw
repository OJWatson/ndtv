
\documentclass{article}
\usepackage{natbib} %for easy biblo
\usepackage{hyperref} %for url links
\usepackage{comment}
\usepackage{color} 
\usepackage{animate}
\usepackage{graphicx}


\begin{document}

% redefine the colors for code, input and output
\definecolor{Sinput}{rgb}{0.19,0.19,0.75}
\definecolor{Soutput}{rgb}{0.2,0.3,0.2}
\definecolor{Scode}{rgb}{0.75,0.19,0.19}
\DefineVerbatimEnvironment{Sinput}{Verbatim}{formatcom = {\color{Sinput}}} 
\DefineVerbatimEnvironment{Soutput}{Verbatim}{formatcom = {\color{Soutput}}}
\DefineVerbatimEnvironment{Scode}{Verbatim}{formatcom = {\color{Scode}}} 
\renewenvironment{Schunk}{}{}

\SweaveOpts{concordance=TRUE}

<<foo,include=FALSE,echo=FALSE>>=
foo <- packageDescription("ndtv")
# disable prompt characters
options(prompt = " ", continue = " ")
@

\title{Workshop materials for learning \Sexpr{foo$Package}: \Sexpr{foo$Title} (Package version \Sexpr{foo$Version})}  
\author{Skye Bender-deMoll}
\maketitle

\tableofcontents

\section{Introduction to workshop}

\subsection{What is ndtv?}
The Network Dynamic Temporal Visualization (\verb@ndtv@) package provides tools for visualizing changes in network structure and attributes over time.
\begin{itemize}
  \item Uses network information encoded in \verb@networkDynamic@ \citep{networkDynamic} objects as its input
  \item Outputs animated movies, timelines and other types of dynamic visualizations of evolving relational structures.
  
  \item The core use-case for development is examining the output of statistical network models (such as those produced by the \verb@tergm@ \citep{tergm} package in \verb@statnet@ \citep{statnet}) and simulations of disease spread across networks. 
  \item Easy to do basic things, but lots of ability to customize.
\end{itemize}

\subsection{Who are we?}
\begin{itemize}
  \item Developed by members of the statnet \url{http://statnet.org} team
  \item This work was supported by grant R01HD68395 from the National Institute of Health.
\end{itemize}

\subsection{Workshop prerequisites}
\begin{itemize}
  \item Familiarity with the R statistical software.  We are not going to cover basics of how to use R
  \item Familiarity with general network and SNA concepts
  \item Experience with statnet packages and data structures preferred but not necessary
  \item Functioning R installation and basic statnet packages already installed. (Instructions on installing R and statnet are located here \url{https://statnet.csde.washington.edu/trac/wiki/Sunbelt2013\#Downloadingstatnet}.) 
  \item A working internet connection (we will install some libraries and download datasets)
\end{itemize}



\subsection{A quick demo from a tergm simulation}
Lets get started with a realistic example. We can render a  simple network animation in the R plot window (no need to follow along in this part)

Let say we've got a statistical model of a dynamic network, and we want to see what it looks like. 
\begin{itemize}
\item Using statnet's \verb@tergm@ package to estimate the parameters for an edge formation and dissolution process which produces a network similar to the Florentine business network (\verb@?ergm::flobusiness@) given as input.  
\item After the model has been estimated, we can take a number of sequential draws from it to see how the network might ``evolve'' over time. 
\item See the tergm workshop and materials\footnote{\url{https://statnet.csde.washington.edu/trac/wiki/Sunbelt2013\#WorkshopMaterials}} for more background on the modeling process
\end{itemize}


First load in the main necessary libraries (each of which loads a bunch of additional R libraries). 

<<includes>>=
library(ndtv)     # dynamic network animations
library(tergm)    # dynamic ergm simulations     
@

Load in the original Florentine business network.
<<label=loading_data,fig=TRUE>>=
data("florentine") # an example network
plot(flobusiness,displaylabels=T)
@


Define basic \verb@stergm@ model with formation and dissolution parameters. The tergm package will do lots of complicated stuff to figure out an appropriate network model.

<<test_model,eval=FALSE,results=hide>>==
#TODO: should set seed?
theta.diss <- log(9)
stergm.fit.1 <- stergm(flobusiness,
  formation= ~edges+gwesp(0,fixed=T), 
  dissolution = ~offset(edges),
  targets="formation",
  offset.coef.diss = theta.diss,	
  estimate = "EGMME"	)
@
(time passes, lots simulation status output hidden)

Now we can simulate a number of discrete time steps from the model and save them as a \verb@dynamicNetwork@ object.
<<test_sim,eval=false, results=hide>>==
stergm.sim.1 <- simulate.stergm(stergm.fit.1,
                    nsim=1, time.slices = 25)
@

NOTE: stergm code above is temporarily turned off while writing examples because it is slow. If we want to avoid loading \verb@tergm@ and running the simulation,  we can load in the pre-generated stergm object and trim it to a shorter length: 
<<pre-load_stergm>>==
data(stergm.sim.1)
stergm.sim.1<-network.extract(stergm.sim.1,onset=0,terminus=25,
                              trim.spells=TRUE)
@

We define some parameters in a list named \verb@render.par@ in order to specify how the movie should be rendered (more on this later). 

<<render.par_animation>>==
render.par=list(tween.frames=5,show.time=TRUE,
                show.stats="~edges+gwesp(0,fixed=T)")
@

Then we ask it to build the animation, passing in some of the standard \verb@plot.network@ graphics arguments to change the color of the edges and show the labels with a smaller size and blue color.
<<render_animation,eval=true,results=hide,include=TRUE>>==
render.animation(stergm.sim.1,render.par=render.par,
                 edge.col="darkgray",displaylabels=T,
                 label.cex=.6,label.col="blue")
@
Rendering takes some time and produces many lines output which we are not showing. The output could also be suppressed by adding a \verb@verbose=FALSE@ argument.

After it has finished, replay the movie in an R plot window.
<<replay_animation,eval=false,include=TRUE>>=
ani.replay()
@   

Notice that in addition to the labels on the bottom of the plot indicating which time step is being viewed, it also displays the network statistics of interest for the time step. When the ``edges'' parameter increases up, you can see the density on the graph increase and the number of isolates decrease. Eventually the model corrects, and the parameter drifts back down. 

An animation is not the only way to display a sequence of views.  We could also use the \verb@filmstrip()@ function that will create a ``small multiple'' plot using frames of the animation to construct a visual summary of the network changes as a static plot.

<<filmstrip,fig=TRUE>>=
filmstrip(stergm.sim.1,displaylabels=FALSE)
@

We can view the dynamics as a timeline or where we plot the existance of edges and vertices over time (but don't show connectivity)
<<timeline,fig=TRUE>>=
timeline(stergm.sim.1)
@

We are experimenting with a form of timeline where vertices are positioned vertically by their proximities to each other over time.

<<proximity_timeline,fig=TRUE>>=
proximity.timeline(stergm.sim.1,default.dist=6,
          mode='sammon',labels.at=17,vertex.cex=4)
@

And of course we can always display the edge spells directly in a tabular form.

<<spell_display>>=
as.data.frame(stergm.sim.1)

@

\noindent\fbox{\parbox{\textwidth}{\textbf{Question:} What are some strengths and weakness of the various views?}}

\noindent\fbox{\parbox{\textwidth}{\textbf{Exercise:} Load the saved version of stergm.sim.1. Are there any edges that are present for the entire time period from 0 until 25?}}

\subsection{Bounds}
Before we create too high of expectations, we should be clear that you can't just throw any network at this and expect good results.

\begin{itemize}
\item Not for ``big data'': So far we've mostly used it successfully with networks of ~1k vertices and several hundred time steps.
\item Animations of dense networks may not be useful. 
\item Works best when a relatively small number of ties are changing between time slices, 
\item Does not work well when vertex turnover rates (births and death) are high.
\end{itemize}

\section{The basics}

Now that we've had a preview of what the package can do, lets get it installed and work through some example in more detail. 

\subsection{Installation and package dependencies}
The \verb@ndtv@ \citep{ndtv} package relies on many other packages to do much of the heavy lifting, especially \verb@animation@ \citep{animation} and \verb@networkDynamic@ and requires external libraries (FFmpeg) to save movies out of the R environment, and Java for some of the better layout algorithms (these will be installed and explained later). 

R should automatically install the dependencies when you install ndtv. So open up your R console, and if you don't already have \verb@ndtv@ installed do the following. 
<<installation>>==
# uncomment this when the appropriate version is on CRAN
#install.packages('ndtv',repos='http://cran.us.r-project.org')
library(ndtv) # also loads animation and networkDynamic
@

\subsection{``Wheel'' work along example}

We are going to build a simple \verb@dynamicNetwork@ object ``by hand'' and then visualize its dynamics. Please follow along by running these commands in your R terminal. 
<<trivial_example>>=
wheel <- network.initialize(10)  # create a toy network
add.edges.active(wheel,tail=1:9,head=c(2:9,1),onset=1:9, terminus=11)
add.edges.active(wheel,tail=10,head=c(1:9),onset=10, terminus=12)
@
We have now created a dynamic network.  Lets verify it.

<<trivial_example_verify>>==
class(wheel)  # now it is also a networkDynamic object
as.data.frame(wheel) # peek at edge dynamics as a data frame
@

Now lets view it as a static plot, but labeling edges with their onset and termination times so we can check our work.

<<trival_example_static,fig=TRUE>>==
# make a list of times for each edge
elabels<-lapply(get.edge.activity(wheel),
                function(spl){
                  paste("(",spl[,1],"-",spl[,2],")",sep='')
                })
# peek at the static version
plot(wheel,displaylabels=TRUE,edge.label=elabels,
     edge.label.col='blue') 
@

\noindent\fbox{\parbox{\textwidth}{\textbf{Question:} Why is this edge labeling function dangerous? (Hint: do edges always have a single onset and terminus time?)}}


Next, render and view it as a dynamic movie 
<<trivial_example_dynamic>>==
render.animation(wheel) # compute and render
ani.replay() # play back in plot window
@

Hopefully, when you ran \verb@ani.replay()@ you saw a bunch of labeled nodes moving smoothly around in the R plot window, with edges slowly appearing to link them into a circle \footnote{An example of the movie is located at \url{http://statnet.csde.washington.edu/movies/ndtv_vignette/wheel.mp4}}. Then a set of ``spoke'' edges appear to draw a vertex into the center, and finally the rest of the wheel diappears. 
  

\subsection{What happened automatically}
Simple right? Most of the difficult parts happened under the hood using default values. 
\begin{enumerate}
  \item We created a \verb@networkDynamic@ object named \verb@wheel@ containing information about the timing of edge activity.
  \item \verb@render.animation()@ asked the package to create an animation for \verb@wheel@ but we didn't include any arguments indicating what should be rendered or how.
  \item Since \verb@render.animation()@ didn't find any stored coordinate information about where to draw the vertices and edges, it (invisibly) called \verb@compute.animation()@ with default arguments to figure out where to position the vertices at each time step.
  \item Because we didn't tell \verb@compute.animation()@ what time points to look at when doing its computations, it reported this, \verb@"No slice.par found"@, and made a guess as to when the animation should start and end (the earliest and latest observed times in the network) and how much time should be incremented between each set of layout coordinate calculations.
  \item \verb@compute.animation()@ then stepped through the \verb@wheel@ network, using \verb@network.collapse()@ to get the approprite active network, computing coordinates for each time step -- using the previous step's coordinates as starting points -- and storing them as a TEA attribute. (This was the \verb@"Calculating layout for network slice from time 1 to 2"@ ... part.)
  \item \verb@render.animation()@ also stepped through the network, using the stored coordinates, \verb@plot.network()@ and \verb@ani.record()@ functions to cache snapshots of the network. It also caches a number of ``tweening'' images between each time step to smoothly interpolate the positions of the vertices. \verb@"rendering 10 frames for slice 1"@ ...
  \item \verb@ani.replay()@ quickly redraws the sequence of cached images in the plot window as an animation. 
\end{enumerate}

\subsection{Doing it step by step}

For more precise control of the processes, layout algorithms, etc, we can call each of the steps in sequence. Lets work through and examine the output

<<wheel_detail_compute>>==
compute.animation(wheel,animation.mode='kamadakawai')
list.vertex.attributes(wheel)
# peek at x coords at time 4
get.vertex.attribute.active(wheel,'animation.x',at=4)
@

Since the coordinates are stored in the network, we could always just collapse the network at the time point and plot it with the appropriate values:
<<wheel_detail_plot_coords,fig=TRUE>>==
wheelAt8<-network.collapse(wheel,at=8)
coordsAt8<-cbind(wheelAt8%v%'animation.x',wheelAt8%v%'animation.y')
plot(wheelAt8,coord=coordsAt8)
@

This is essentially what \verb@render.animation@ does internally, which is why we can pass in the standard network plotting arguments

<<wheel_detail_render>>==
render.animation(wheel,vertex.col='blue',edge.col='gray')
@

We can adjust how many ``tweening'' frames are rendered. This indirectly impacts the perceived speed of the movie (more means slower and smoother). If we wanted no animation smoothing at all, set \verb@tween.frames=1@.

<<wheel_detail_tween_render2>>==
render.animation(wheel,render.par=list(tween.frames=1),
                 vertex.col='blue',edge.col='gray')
ani.replay()
@

Or bump it up to 30

<<wheel_detail_tween_render>>==
render.animation(wheel,render.par=list(tween.frames=30),
                 vertex.col='blue',edge.col='gray')
ani.replay()
@

If you are like me, you probably forget what the various parameters are and what they do.  You can use \verb@?compute.animation@ or \verb@?render.animation@ to display the appropriate help files. and \verb@?plot.network@ to show the list of plotting control arguments.


\noindent\fbox{\parbox{\textwidth}{\textbf{Question:} Why is all this necessary? Why not just call plot.network over and over at each time point?}}

\section{Installing external dependencies}
\label{sec:dependencies}

In order to save out animations as video files and use the better-quality layouts, we need to install some additional non-R software dependencies. 

\subsection{FFmpeg for saving animations}
FFmpeg \url{http://ffmpg.org} is a cross-platform tool for converting and rendering video content in various formats. It is used as an external library by the \verb@animation@ package to save out the animation as a movie file on disk. (see \verb@?saveVideo@ for more information.) Since FFmpeg is not part of R, you will need to install it separately on your system for the save functionality to work.  The instructions for how to do this will be different on each platform.  You can also access these instructions using \verb@?install.ffmpeg@
<<install_ffmpeg>>==
?install.ffmpeg   # help page for installing ffmpeg
@


\subsection{Java and MDSJ setup}
To use the MDSJ layout algorithm, you must have Java installed on your system.  Java should be already installed by default on most Mac and Linux systems. If it is not installed, you can download it from \url{http://www.java.com/en/download/index.jsp}. On Windows, you may need to edit your `Path' environment variable to make Java executable from the command-line. 

When java is installed correctly the following command should print out the version information:
<<java_version>>==
system('java -version')
@

Due to CRAN's license restrictions, necessary components of the MDSJ layout (which we will use in a minute) are not distributed with ndtv.  Instead, the first time the MDSJ layout is called after installing or updating the ndtv package, it is going to ask to download the library.  Lets do that now on a pretend movie to get it out of the way:

<<mdsj_download,results=hide>>==
network.layout.animate.MDSJ(network.initialize(1))
@

<<mdsj_actual_download,echo=FALSE>>==
# the command above will default to not installing MDSJ in a non-interactive session
# so to make sure it is installed for this sweave build, call it internally
mdsj.dir <- file.path(path.package("ndtv"), "exec/")
ndtv:::install.mdsj(mdsj.dir)
@
This will give a prompt like

\begin{verbatim}
The MDSJ Java library does not appear to be installed. 
The ndtv package can use MDSJ to provide a fast 
accurate layout algorithm. It can be downloaded from 
http://www.inf.uni-konstanz.de/algo/software/mdsj/
Do you want to download and install the MDSJ Java library? (y/N):
\end{verbatim}

Responding \verb@y@ to the prompt should install the library and print the following message:
\begin{verbatim}
MDSJ is a free Java library for Multidimensional Scaling (MDS).
It is a free, non-graphical, self-contained, lightweight 
implementation of basic MDS algorithms and intended to be used 
both as a standalone application and as a building block in 
Java based data analysis and visualization software. 

CITATION: Algorithmics Group. MDSJ: Java Library for 
Multidimensional Scaling (Version 0.2). Available at 
http://www.inf.uni-konstanz.de/algo/software/mdsj/. 
University of Konstanz, 2009. 

USE RESTRICTIONS: Creative Commons License 'by-nc-sa' 3.0.
\end{verbatim}

And its good to go! (unless you were intending to use the layout for commercial work...)
 

\section{Demonstrate output formats}
Now that we've got ffmpeg installed, we can save out some movies in useful formats. 

The \verb@animation@ package provides several neat tools for storing animations once they have been rendered.
\begin{itemize}
\item \verb@ani.replay()@ plays the animation back in the R plot window. (see \verb@?ani.options@ for more parameters)
\item \verb@saveVideo()@ saves the animation as a movie file on disk (if the FFmpeg library is installed).
\item \verb@saveGIF()@ creates an animated GIF (if ImageMagick's convert installed)
\item \verb@saveLatex()@ creates an animation embedded in a pdf
\end{itemize}
Please see \verb@?animation@ and each function's help files for more details. 

\subsection{saveVideo}
Since we just rendered the ``wheel'' example movie, it is already cached so we can capture the output of \verb@ani.replay@ into a movie file. Try out the various output options below.

<<save_video>>==
saveVideo(ani.replay(),video.name="wheel_movie.mp4")
@

Sometimes we may want to change the pixel dimensions of the movie output.
<<save_video_dimensions>>==
saveVideo(ani.replay(),video.name="wheel_movie.mp4",
          ani.width=800,ani.height=800)
@

We can increase the video's image quality (and file size) by telling ffmpeg to use a higher bit-rate (less compression), although this setting mostly impacts jpeg output. 
<<save_video_bitrate>>==
saveVideo(ani.replay(),video.name="wheel_movie.mp4",
          other.opts="-b 5000k")
@

Because the \verb@ani.record()@ and \verb@ani.replay()@ functions cache each plot image in memory, they are not very speedy and will tend to bog down as memory fills up when rendering large networks or long movies.  We can avoid this by saving the output of \verb@render.animation@ directly to disk by wrapping it inside the \verb@saveVideo()@ call and setting \verb@render.cache='none'@.
<<save_video_direct,results=hide>>==
saveVideo(render.animation(wheel,vertex.col='blue',
          edge.col='gray',render.cache='none'),
          video.name="wheel_movie.mp4")
@

\subsection{saveGIF}
We can also export it as an animated gif image. Gif animations will be very large files, but very portable for sharing on the web (assuming you happen to have ImageMagick installed...).

<<save_video,results=hide>>==
saveGIF(render.animation(wheel,vertex.col='blue',
          edge.col='gray',render.cache='none'),
         movie.name="wheel_movie.gif")
@

\subsection{saveLatex}
<<save_latex_example,results=hide>>==
saveLatex(render.animation(wheel,vertex.col='blue',
          edge.col='gray',render.cache='none'))
@


\noindent\fbox{\parbox{\textwidth}{\textbf{Exercise:} Using the list of options from the help page ?ani.options, locate the option to control the time interval of the animation, and use it to render a gif where each frame stays on screen for 2 seconds.}}


\section{Comparing Layout algorithms}
Producing ``good'' (for an admittedly ambiguous definition of good) layouts of networks is generally a computationally difficult problem. 

Common goals:
\begin{itemize}
\item Layouts should remain as stable as possible over time. 
\item Small changes in the network structure should lead to small changes in the layouts. 
\end{itemize}
Many otherwise excellent static layout algorithms are not stable in this sense, or they may require very specific parameter settings to improve their results for animation applications. 

So far, in ndtv we are using variations of Multidimensional Scaling (MDS) layouts.  MDS algorithms use various numerical optimization techniques to find a configuration of points (the vertices) in a low dimensional space (the screen) where the distances between the points are as close as possible to the desired distances (the edges). This is analgous to the process of squashing a 3D world globe onto a 2D map: there are many useful ways of doing the projection, but each introduces some type of distortion.

The \verb@network.layout.animate.*@ layouts included in \verb@ndtv@ are adaptations or wrappers for existing static layout algorithms with some appropriate parameter presets. They all accept the coordinates of the previous layout as an argument so that they can try to construct a suitably smooth sequence of node positions. Using the previous coordinates allows us to ``chain'' the layouts together. Each step can often avoid some work by using a previous solution as its sarting point, and it is likely to find a solution that is similar to previous step.  

\subsection{Why we don't (yet) use Fruchterman-Reingold}
The Fruchterman-Reingold (CITE) algorithm has been one of the most popular layout algorithms (it is the default for \verb@plot.network@).  For larger networks it can be tuned to run much more quickly than most MDS algorithms.  Unfortunately, its default optimization is based on a sort of simulated aneeling approach, so ``memory'' of previous positions is usually erased each time the layout is run\footnote{Various authors have had useful animation results by modifying FR to explicitly include references to vertices' positions in previous time points. Hopefully we will be able to include such algorithms in future releases of ndtv.}, producing very unstable layouts. 

\subsection{Kamada-Kawai adaptation}
The Kamada-Kawai network layout algorithm is often described as ``spring embeddder'' simulation, but it is mathamatically equivilent to some forms of MDS. The function \verb@network.layout.animate.kamadakawai@ is essentially a wrapper for \verb@network.layout.kamadakawai@. It computes a symmetric geodesic distance matrix from the input network (replacing infinite values with \verb@default.dist@), and seeds the initial coordinates for each slice with the results of the previous slice in an attempt to find solutions that are as close as possible to the previous positions. It is not as fast as MDSJ, and the layouts it produces are not as smooth. But it has the advantage of being written entirely in R, so it doesn't have the pesky external dependencies of MDSJ. For this reason it is the default layout algorithm. 

\subsection{MDSJ (Multidimensional Scaling for Java)}

MDSJ is a very efficient implementation of ``SMACOF'' stress-optimization Multidimensonal Scaling so \verb@network.layout.animate.MDSJ@ gives the best performance of any of the algorithms tested so far -- despite the overhead of writing matrices out to a Java program and reading coordinates back in.  It also produces very smooth layouts with less of the wobbling and flipping which can sometimes occur with Kamada-Kawai

As noted earlier, the MDSJ library is released under Creative Commons License ``by-nc-sa'' 3.0.  This means using the algorithm for commercial purposes would be a violation of the license. More information about the MDSJ library and its licensing can be found at \url{http://www.inf.uni-konstanz.de/algo/software/mdsj/}.

\subsection{Graphviz layouts}

The Graphviz \citep{graphviz} external layout library includes a number of excellent algorithms for graph layout, including \verb@neato@, an stress-optimization varient, and \verb@dot@ a hierarchial layout (for trees and DAG networks). 

\subsection{Use a TEA attribute or write your own}
The \verb@useAttribute@ layout is useful if you already know exactly where each vertex should be drawn at each time step (based on external data, like latitude and longitude), and you just want to render out the network\footnote{It is also possible to write your own layout function and easily plug it in.  See the ndtv package vignette for an example circular layout.}.  It just needs to know the names of the dynamic attribute holding the x coordinate and the y coordinate for each time step. 

TODO: include layout time comparison plots


\section{Slicing time}

The basic network layout algorithms we are using, like most ``traditional'' network metrics, don't really know what to do with dynamic networks.  They need to be fed a static set of relationships which can be used to compute a set of distances in a Euclidean space suitable for plotting.  A common way to apply static metrics to a time-varying object is to sample it, taking a sequence static observations at a series of time points and using these to describe the changes over time.  In the case of networks, we might call this this ``extracting'' or ``slicing''.

\subsection{Slicing panel data}

In both the \verb@wheel@ and \verb@stergm.sim.1@ examples, we've been implicitly slicing up time, extracting a static network at each unit time step.

We can plot the slice bins against the timeline of edges to visualize our ``observations'' of the network. When the horizontal line corresponding to and edge spell crosses the vertical gray bar corresponding to a bin, the edge would be included in that network. If this was a social network survey, each slice would correspond to one data collection panel of the network.  
<<slicing_panels,fig=TRUE>>=
timeline(stergm.sim.1,slice.par=list(start=0,end=25,interval=1,
                      aggregate.dur=1,rule='latest'),
                      plot.vertex.spells=FALSE)
@

Looking at the first slice, which extends from time zero \emph{until}\footnote{notice the right-open interval definition!} time 1, it appears that it should have 15 edges in it.  Let's check:

<<slicing_panels1b>>=
# extract network and count edges
network.edgecount(network.extract(stergm.sim.1,onset=0,terminus=1))
# or just count active edges directly
network.edgecount.active(stergm.sim.1,onset=0,terminus=1)
@

Because this is a discrete time network, the edge spells always extend the full duration of the slice, so it wouldn't actually matter if we used a shorter \verb@aggregate.dur@. Each slice will still intersect with the same set of edges. 

<<slicing_panels2,fig=TRUE>>=
timeline(stergm.sim.1,slice.par=list(start=0,end=25,interval=1,
                      aggregate.dur=0,rule='latest'),
                      plot.vertex.spells=FALSE)
@


Some datasets that are collected as panels the time units many not be integers, so the slicing paramters might need to be adjusted to the natrual time units.  And, as we will see later in the windsurfers example, there are situations where using longer aggregation durations can be hellpful even for panel data. 

\subsection(Slicing streaming data)

Slicing up a dynamic network created from discrete panels may be fairly straightforward but it is much less clear how to do it when working with continuous time or streaming relations. How often should we slice?  Should the slices measure the state of the network at a specific instant, or aggregate over a longer time period?  The answer probably depends on what the important features to visualize are in your data-set. The \verb@slice.par@ parameters make it possible to experiment with various slicing options. In many situations we have even found \citep{sonia} it useful to let slices mostly overlap -- increment each one by a small value to help show fluid changes on a moderate timescale instead of the rapid changes happening on a fine timescale. 

As an example, lets look at the McFarland \citep{mcfarland} data-set of streaming classroom interactions and see what happens when we chop it up in various ways. First, we can animate at the fine time scale, viewing the first half-hour of class using instantaneous slices.
<<mcfarla,results=hide,fig=TRUE>>=
data(McFarland_cls33_10_16_96)
# plot the time-aggregated network
plot(cls33_10_16_96)
slice.par<-list(start=0,end=30,interval=2.5, 
                aggregate.dur=0,rule="latest")
compute.animation(cls33_10_16_96,
                slice.par=slice.par,animation.mode='MDSJ')
render.animation(cls33_10_16_96,
                 displaylabels=FALSE,vertex.cex=1.5)
ani.replay()
@

Notice that although the plot shows a start structure, in the animation most of the vertices are isolates, occasionally linked into brief pairs or stars by speech acts\footnote{\url{http://statnet.csde.washington.edu/movies/ndtv_vignette/cls33_10_16_96v1.mp4}}. Once again we can get an idea of what is going on by slicing up the network by using the \verb@timeline()@ function to plot the \verb@slice.par@ parameters against the vertex and edge spells. Although the vertices have spells spanning the entire time period, the edges are recorded as instantaneous ``events'' with no durations.  The very thin slices (gray vertical lines) (\verb@aggregate.dur=0@) are not intersecting many edge events (purple numbers) at once so the momentary degrees are mostly low. 

<<mcfarla_timeline1,fig=TRUE>>=
timeline(cls33_10_16_96,slice.par=slice.par)
@

 However, if we aggregate over a longer time period of 2.5 minutes we start to see the individual acts form into triads and groups\footnote{\url{http://statnet.csde.washington.edu/movies/ndtv_vignette/cls33_10_16_96v2.mp4}}. 

<<mcfarla2,results=hide>>=
slice.par<-list(start=0,end=30,interval=2.5, 
                aggregate.dur=2.5,rule="latest")
compute.animation(cls33_10_16_96,
                slice.par=slice.par,animation.mode='MDSJ')
render.animation(cls33_10_16_96,
                 displaylabels=FALSE,vertex.cex=1.5)
ani.replay()
@

To reveal slower structural patterns we can make the aggregation period even longer, and let the slices overlap (by making \verb@interval@ less than \verb@aggregate.dur@) so that the same edge may appear in sequential slices and the changes will be less dramatic between successive views\footnote{\url{http://statnet.csde.washington.edu/movies/ndtv_vignette/cls33_10_16_96v3.mp4}}.

<<mcfarla3,results=hide,fig=TRUE>>=
slice.par<-list(start=0,end=30,interval=1, 
                aggregate.dur=5,rule="latest")
timeline(cls33_10_16_96,slice.par=slice.par)
compute.animation(cls33_10_16_96,
                slice.par=slice.par,animation.mode='MDSJ')
render.animation(cls33_10_16_96,
                 displaylabels=FALSE,vertex.cex=1.5)
ani.replay()
@

Note that when we use a long duration slice, it is quite likely that the edge between a pair of vertices has more than one active period. How should this condition be handled? If the edge has attributes, which ones should be shown? 

Ideally we might want to aggregate the edges in some way, perhaps adding the weights together. Currently edge attributes are not aggregated and the \verb@rule@ element of the \verb@slice.par@ argument controls which attribute should be returned for an edge when multiple elements are encountered.  Generally \verb@rule='latest'@ gives reasonable results, returning the most recent value found within the query spell. 

\noindent\fbox{\parbox{\textwidth}{\textbf{Exercise:} Define a slice.par and render an animation of the first 15 minutes of classroom interactions using 5 minute non-overlapping slices }}


\section{Vertex dynamics}
Edges are not the only things that can change in networks. In some dynamic network data-sets vertices also enter or leave the network (become active or inactive).  Lin Freeman's windsurfer social interaction data-set \citep{windsurfers} is a good example of this. In this data-set there are different people present on the beach on different days, and there is even a day of missing data.


<<windsurfers,eval=true,include=TRUE>>=
data(windsurfers)
slice.par<-list(start=1,end=31,interval=1, 
                aggregate.dur=1,rule="latest")
windsurfers<-compute.animation(windsurfers,slice.par=slice.par,
                               default.dist=3,
                               animation.mode='MDSJ',
                               verbose=FALSE)
render.animation(windsurfers,vertex.col="group1",
                 edge.col="darkgray",
                 displaylabels=TRUE,label.cex=.6,
                 label.col="blue", verbose=FALSE)
ani.replay()
@

These networks also have a lot of isolates, which tends to scrunch up the rest of the components so they are hard to see.  Setting the lower \verb@default.dist@ above can help with this. 

In this example\footnote{\url{http://statnet.csde.washington.edu/movies/ndtv_vignette/windsurfers_v1.mp4}} the turnover of people on the beach is so great that structure appears to change chaotically, and it is quite hard to see what is going on. Vertices enter and exit frequently and are often not availible for observation on sucessive days. For example, look at vertex 74 or the timeline plot below.

<<windsurfers2,fig=TRUE>>=
timeline(windsurfers,plot.edge.spells=FALSE,lwd=3)
@

Notice the blank period at day 25 where the network data is missing. There is also a lot of periodicity, since a lot more people go to the beach on weekends. So in this case, lets try a week-long slice by setting \verb@aggregate.dur=7@ to try to smooth it out so we can see some structure. 

<<windsurfers3>>=
slice.par<-list(start=0,end=24,interval=1, 
                aggregate.dur=7,rule="latest")
windsurfers<-compute.animation(windsurfers,slice.par=slice.par,
                               default.dist=3,
                               animation.mode='MDSJ',
                               verbose=FALSE)
render.animation(windsurfers,vertex.col="group1",
                 edge.col="darkgray",
                 displaylabels=TRUE,label.cex=.6,
                 label.col="blue", verbose=FALSE)
ani.replay()
@

This new rolling--``who interacted this week'' network\footnote{\url{http://statnet.csde.washington.edu/movies/ndtv_vignette/windsurfers_v2.mp4}} is larger and more dense (which is to be expected) and also far more stable. There is still some turnover due to people who don't make it to the beach every week but is possible to see some of the sub-groups and the the various bridging individuals. 

\section{Animating graphic attributes}
Vertices and edges are not the only things that change over time, how do we show dynamic attributes and changes to structural properties of the network?

\subsection{Using dynamic attributes (TEAs)}
If a network has dynamic attributes defined, they can be used to define graphic properties of the network which change over time.  We can activate some attributes on our earlier ``wheel'' example, setting a dynamic attribute for edge widths:

<<color_wheel>>=
activate.edge.attribute(wheel,'width',1,onset=0,terminus=3) 
activate.edge.attribute(wheel,'width',5,onset=3,terminus=7)
activate.edge.attribute(wheel,'width',10,onset=3,terminus=Inf)
@

We must make sure the attributes are always defined for each time period that the network will be plotted or else an error will occur. So we first set a default value from \verb@-Inf@ to \verb@Inf@  before defining which elements we wanted to take a special value. 
<<color_wheel2>>=
activate.vertex.attribute(wheel,'mySize',1, onset=-Inf,terminus=Inf)
activate.vertex.attribute(wheel,'mySize',3, onset=5,terminus=10,v=4:8)
@

We can set values for vertex colors.
<<color_wheel3>>=
activate.vertex.attribute(wheel,'color','gray',onset=-Inf,terminus=Inf)
activate.vertex.attribute(wheel,'color','red',onset=5,terminus=6,v=4)
activate.vertex.attribute(wheel,'color','green',onset=6,terminus=7,v=5)
activate.vertex.attribute(wheel,'color','blue',onset=7,terminus=8,v=6)
activate.vertex.attribute(wheel,'color','pink',onset=8,terminus=9,v=7)
@

Finally we render it, giving the names of the dynamic attributes to be used to control the plotting parameters for edge with, vertex size, and vertex color. 

<<color_wheel4>>=
render.animation(wheel,edge.lwd='width',vertex.cex='mySize',
                 vertex.col='color',verbose=FALSE)
ani.replay()
@

The attribute values for the time points are defined using \verb@network.collapse@, which controls the behavior if multiple values are active for the plot period. 

\noindent\fbox{\parbox{\textwidth}{\textbf{Exercise:} Using the wheel network, create a dynamic vertex attributed named ``group''.  Define the TEA so that initially most of the vertices will be in group ``A'', but over time more and more will be in group ``B'' }}

\subsection{Functional plot arguments}

Sometimes it is awkward or inefficient to pre-generate dynamic attribute values.  Why create and another attribute for color if it is just a simple transformation of an existing attribute or measure? The \verb@render.animation@ function has the ability to accept the \verb@plot.network@ arguments as functions with special arguments to be evaluated on the fly at each time point as the network is rendered. So, for example, if we wanted to use our previously created ``width'`'' attribute to control the color of edges along with their width:

<<wheel_color_function>>=
render.animation(wheel,edge.lwd=3, 
    edge.col=function(slice){rgb((slice%e%'width')/10,0,0)},
    verbose=FALSE)
ani.replay()
@

Notice the use of the \verb@slice@ argument to the function instead of the original name of the network. The arguments of plot control functions must draw from a specific set of named arguments which will be substituted in and evaluated at each time point before plotting.  The set of valid argument names is:
\begin{itemize}
  \item \verb@net@ is the original (un-collapsed) network
  \item \verb@slice@ is the network collapsed to be rendered with the appropriate onset and terminus
  \item \verb@s@ is the slice number in the sequence to be rendered
  \item \verb@onset@ is the onset (start time) of the slice to be rendered
  \item \verb@terminus@ is the terminus (end time) of the slice to be rendered
\end{itemize}

So in the example above, at each time point the edge attribute ``width'' is extracted and used to control the red component of the rgb color. We can also define functions based on network measures such as betweenness: 

<<wheel_betweeness_function>>=
require(sna)
wheel%n%'slice.par'<-list(start=1,end=10,interval=1, 
                          aggregate.dur=1,rule='latest')
render.animation(wheel,
      vertex.cex=function(slice){(betweenness(slice)+1)/5},
      verbose=FALSE)
ani.replay()
@

\noindent\fbox{\parbox{\textwidth}{\textbf{Exercise:} write a functional plot argument that scales vertex size in proportion to momentary degree}}

In this example we had to modify the start time using the \verb@slice.par@ setting to avoid time 0 because the \verb@betweenness@ function will give an error for a network with no edges.  The main plot commands accept functions as well, so it is possible to do fun things like implement a crude zoom effect by setting \verb@xlim@ and \verb@ylim@ parameters to be dependent on the time. 

<<wheel_zoom>>=
render.animation(wheel,
      xlim=function(onset){c(-5/(onset*0.5),5/(onset*0.5))},
      ylim=function(onset){c(-5/(onset*0.5),5/(onset*0.5))},
      verbose=FALSE)
ani.replay()
@


\section{Using and aggregating edge weights}
When we are looking at an aggregate network, should an edge that exists for a single moment be treated the same way as an edge that exists the entire time?

Collapse a network, and tell it not to remove the time related info
<<edge_weights>>=
simAgg <-network.collapse(stergm.sim.1,rm.time.info=FALSE)
list.edge.attributes(simAgg)
@

Notice the \verb@activity.count@ and \verb@activity.duration@ that are now attached to the edges. Lets plot it, using those durations to control the edge width.

<<edge_weights_plot,fig=TRUE>>=
plot(simAgg,edge.lwd='activity.duration',edge.col='#00000055',
     edge.label='activity.duration',edge.label.col='blue',
     edge.label.cex=0.5)
@

We have to go through some convoluted steps to illustrate the example, but instructing the layout to use the edge weight is really just a matter of telling the name of the attribute to use.

Ignore edge weights
<<edge_weights_ignore,fig=TRUE>>=
stergm.sim.1%n%'slice.par'<-list(start=0,end=25,interval=25, 
                                 aggregate.dur=25,rule='latest')
compute.animation(stergm.sim.1,animation.mode='MDSJ')
# extract the coords so we can do a static plot
coords<-cbind(get.vertex.attribute.active(stergm.sim.1, 'animation.x',at=0),
              get.vertex.attribute.active(stergm.sim.1, 'animation.y',at=0))
plot(simAgg,coord=coords,
     edge.lwd='activity.duration', edge.col='#00000055',
     edge.label='activity.duration',edge.label.col='blue',
     edge.label.cex=0.5)
@

Now compute the layout so that the higher-valued edges draw vertices closer together (the default \verb@weight.dist=FALSE@ considers edge weights to be similarities)
<<edge_weights_similarity,fig=TRUE>>=
compute.animation(stergm.sim.1,weight.attr='activity.duration',
                  animation.mode='MDSJ',seed.coords=coords,default.dist=20)
coords<-cbind(get.vertex.attribute.active(stergm.sim.1, 'animation.x',at=0),
              get.vertex.attribute.active(stergm.sim.1, 'animation.y',at=0))
plot(simAgg,coord=coords,
     edge.lwd='activity.duration', edge.col='#00000055',
     edge.label='activity.duration',edge.label.col='blue',
     edge.label.cex=0.5)
@

Compute layout with \verb@weight.dist=FALSE@ so weights are treated as distance and higher-valued edges push vertices further apart.
<<edge_weights_distance,fig=TRUE>>=
compute.animation(stergm.sim.1,weight.attr='activity.duration',
                  weight.dist=TRUE, animation.mode='MDSJ',
                  seed.coords=coords,default.dist=20)
coords<-cbind(
  get.vertex.attribute.active(stergm.sim.1, 'animation.x',at=0),
  get.vertex.attribute.active(stergm.sim.1, 'animation.y',at=0)
)
plot(simAgg,coord=coords,
     edge.lwd='activity.duration', edge.col='#00000055',
     edge.label='activity.duration',edge.label.col='blue',
     edge.label.cex=0.5)
@

Although we can clearly see that the layout is trying to do what we ask it, the result is a graph that is visually hard to read.  Part of the problem is that we are asking the layout to achieve something difficult: the edge weights (and corresponding desired lengths) differ by more than an order of magnitude
<<edge_weights_log,fig=TRUE>>=
range(simAgg%e%'activity.duration')
range(log(simAgg%e%'activity.duration'+1))
set.edge.attribute(stergm.sim.1,'logDuration',
                   log(simAgg%e%'activity.duration'+1))
compute.animation(stergm.sim.1,
              weight.attr='logDuration',
                  animation.mode='MDSJ',seed.coords=coords)
coords<-cbind(
  get.vertex.attribute.active(stergm.sim.1, 'animation.x',at=0),
  get.vertex.attribute.active(stergm.sim.1, 'animation.y',at=0))
plot(simAgg,coord=coords,
     edge.lwd='activity.duration', edge.col='#00000055',
     edge.label='activity.duration',edge.label.col='blue',
     edge.label.cex=0.5)
@

Which gives us somethig better looking--big edges are a bit shorter, but not so much to squinch up the layout.

\noindent\fbox{\parbox{\textwidth}{\textbf{Question:} What types of data have edge weights that would best be thought of as distances? Similarities?}}

\section{How to make plots with isolates and components look better: layout.distance}
We've breifly mentioned the \verb@default.dist@ parameter which can be tweaked to increase or decrease the spacing between isolates and disconnected components. The default value for \verb@default.dist@ is \verb@sqrt(network.size(net))@, see \verb@?layout.dist@ for more information. 

We will work with a single static slice of the network, and call the animation layout directly so we can avoid rendering out the entire movie for each test. 

<<default_dist_example,fig=TRUE>>==
data(msm.sim)
msmAt50<-network.extract(msm.sim,at=50)
network.size(msmAt50)
plot(msmAt50,coord=network.layout.animate.MDSJ(msmAt50),vertex.cex=0.5)
@

In this case, the default distance must have been set to about 31 (square root of 10000). This results in the giant component being well separated from the smaller components and isolates. Although this certainly focuses visual attention on the big component, it squishes up the rest of the network.  We can set it smaller.

<<default_dist_example2,fig=TRUE>>==
plot(msmAt50,coord=network.layout.animate.MDSJ(msmAt50,default.dist=10),
     vertex.cex=0.5)
@

But in the example above, the \verb@default.dist@ value was too small to effectively separate the components, resulting in a lot of uncessary edge crossing. 

<<default_dist_example3,fig=TRUE>>==
plot(msmAt50,coord=network.layout.animate.MDSJ(msmAt50,default.dist=18),
     vertex.cex=0.5)
@

For this network, \verb@default.dist=18@ seems to give a reasonable compromise between spacing and scaling, but it can still lead to some edge overlaps.  We can now compute the overall movie to see how it works.  (this is going to be slow..).  And then peek at four time points to see if the parameter is going to give reasonable values over the time range of the movie. 

<<default_dist_example4,fig=FALSE>>==
#TODO: disabled to save time while writing doc
#compute.animation(msm.sim,animation.mode='MDSJ',default.dist=18)
#filmstrip(msm.sim,frames=4,displaylabels=FALSE,vertex.cex=0.5)
@

So it seems like it will work acceptably, but by the end of the movie the giant component will have grown enough to start squishing the rest of the network. 


\section{Advanced example}

We will construct a fictitious rumor transmission network using code from the ``Making Lin Freeman's windsurfers gossip'' section of the \verb@networkDynamic@ vignette, and then examine various ways to look at the transmission.  

The code below defines a function to run the simulation, sets initial seeds (starts the rumor) and then runs the simulation \footnote{The EpiModel package includes much better utilties for simulating transmission networks with various realistic properties}.  If you don't care about the details, just execute the entire block of code. 

<<windsim>>==
# function to simulate transmission
runSim<-function(net,timeStep,transProb){
  # loop through time, updating states
  times<-seq(from=0,to=max(get.change.times(net)),by=timeStep)
  for(t in times){
    # find all the people who know and are active
    knowers <- which(!is.na(get.vertex.attribute.active(
      net,'knowsRumor',at=t,require.active=TRUE)))
    # get the edge ids of active friendships of people who knew
    for (knower in knowers){
      conversations<-get.edgeIDs.active(net,v=knower,at=t)
      for (conversation in conversations){
        # select conversation for transmission with appropriate prob
        if (runif(1)<=transProb){
          # update state of people at other end of conversations
          # but we don't know which way the edge points so..
          v<-c(net$mel[[conversation]]$inl,
                 net$mel[[conversation]]$outl)
          # ignore the v we already know and people who already know
          v<-v[!v%in%knowers]
          if (length(v)){
            activate.vertex.attribute(net,"knowsRumor",TRUE,
                                      v=v,onset=t,terminus=Inf)
            # record who spread the rumor
            activate.vertex.attribute(net,"heardRumorFrom",knower,
                                    v=v,onset=t,length=timeStep)
            # record which friendships the rumor spread across
            activate.edge.attribute(net,'passedRumor',
                      value=TRUE,e=conversation,onset=t,terminus=Inf)
          }
        }
      }
    }  
  }
  return(net)
}
@

We next need to load in the data with the edge dynamics, and set up the initial state of the sim, and then use the function we defined above to propagate the rumor. 


<<windsim_initialize>>=
data(windsurfers)    # let's go to the beach!

# set initial params...
timeStep <- 1  # units are in days
transProb <- 0.2 # how likely to tell in each conversation/day
# start the rumor out on vertex 1
activate.vertex.attribute(windsurfers,"knowsRumor",TRUE,v=1,
                          onset=0-timeStep,terminus=Inf)
activate.vertex.attribute(windsurfers,"heardRumorFrom",1,v=1,
                          onset=0-timeStep,length=timeStep)
activate.edge.attribute(windsurfers,'passedRumor',value=FALSE,
                        onset=-Inf,terminus=Inf)
# run the sim!
windsurfers<-runSim(windsurfers,timeStep,transProb)
@

So now the windsurfers network should have dynamic attributes indicating who knows the rumor, who they heard it from, and which edges passed it. 

<<windsim2>>=
list.vertex.attributes(windsurfers)
list.edge.attributes(windsurfers)
@

Lets plot the time-aggregate network with the infected vertices and edges highlighted
<<windsim3,fig=TRUE>>=
# plot the aggregate network, hiliting infected
plot(windsurfers,
     vertex.col=ifelse(
       !is.na(get.vertex.attribute.active(windsurfers,'knowsRumor',at=31)),
       'red','#55555555'
     ),
     edge.col=ifelse(
       get.edge.attribute.active(windsurfers,'passedRumor',at=31),
       'red','#55555555'
     ),
     vertex.cex=0.5
)
@

Since we know that the high rate of vertex dynamics makes it hard to see this as a movie, we can create a ``flip-book'' style movie, where we will keep the vertex positions fixed, and just animate the dynamics.

\noindent\fbox{\parbox{\textwidth}{\textbf{Question:} It a network has a high-turnover vertex set, should it be considered to be a dynamic network?}}

<<windsim4,results=hide>>=
# record the coords produced by plot
coords<-plot(windsurfers)
# set them as animation coords directly,without layout
activate.vertex.attribute(windsurfers, 'animation.x',coords[,1], 
                          onset=-Inf, terminus=Inf)
activate.vertex.attribute(windsurfers, 'animation.y',coords[,2],
                          onset=-Inf,terminus=Inf)

# construct slice par to indicate time range to render
windsurfers%n%'slice.par'<-list(start=-31,end=0,interval=1, 
                                aggregate.dur=31,rule='latest')
# render it
saveVideo(
  render.animation(windsurfers,
            render.par=list(initial.coords=coords),
            # color edges by rumor status       
            edge.col=function(slice){
              ifelse(slice%e%'passedRumor','red','#00000055')
            },
            # color vertices by rumor status       
            vertex.col=function(slice){
              ifelse(!is.na(slice%v%'knowsRumor'),'red','gray')
            },
            # change text of label to show time and total infected.        
            xlab=function(slice,terminus){
              paste('time:',terminus,' total infected:',
                    sum(slice%v%'knowsRumor',na.rm=TRUE))
            },       
            vertex.cex=0.8,label.cex=0.8,render.cache='none'
  )
  ,video.name='windsurferFlipbook.mp4'
)
@

Notice that we did something really funky with the \verb@slice.par@ parameters.  We are using \verb@aggregate.dur=31@, equal to the entire duration of the network, and started at -31, so we are sliding along a giant bin, which is gradually accumulating more of the network edges with each step.  We also used an initial coordinate setting for the vertices (otherwise they would appear at zero when first entering) and functional attribute definitions for vertex and edge colors. 

In this view, it is still quite difficult to see the sequence of infections and the infection path.  So lets try extracting that so that we can visualize it directly.  The function below will create a network consisting only of the rumor-infected vertices and edges in the original network that passed the rumor.  The edges will be directed, so we can see it as a tree.  Don't need to look at this in detail, just load it up. 


<<windsim5>>=
# function to extract the transmission tree
# as a directed network
transTree<-function(net){
  # for each vertex in net who knows
  knowers <- which(!is.na(get.vertex.attribute.active(net,
                                        'knowsRumor',at=Inf)))
  # find out who the first transmission was from
  transTimes<-get.vertex.attribute.active(net,"heardRumorFrom",
                      onset=-Inf,terminus=Inf,return.tea=TRUE)
  # subset to only ones that know
  transTimes<-transTimes[knowers]
  # get the first value of the TEA for each knower
  tellers<-sapply(transTimes,function(tea){tea[[1]][[1]]})
  # create a new net of appropriate size 
  treeIds <-union(knowers,tellers)
  tree<-network.initialize(length(treeIds),loops=TRUE)
  # copy labels from original net
  set.vertex.attribute(tree,'vertex.names',treeIds)
  # translate the knower and teller ids to new network ids   
  # and add edges for each transmission                
  add.edges(tree,tail=match(tellers,treeIds), 
            head=match(knowers,treeIds) )               
  return(tree)                
}
@

Now lets use the \verb@transTree()@ function to find the transmission tree, and plot it just for curiosity.

<<windsim6,fig=TRUE>>=
windTree<-transTree(windsurfers)
plot(windTree,displaylabels=TRUE)
@

Now that we know how things work, we don't necessarily have to \verb@compute.animation@ to construct the sequence of coordinates.  If we are careful, we can even use coordinates from one layout and apply them to another.  In the next example, we will create an animated transition from the full cumulative network into a hierarchical representation of the transmission tree.

First, lets compute a layout for the cumulative across-time network
<<windsim7,fig=TRUE>>=
# calculate coord for aggregate network
windAni<-network.collapse(windsurfers,onset=-Inf,terminus=Inf,
                          rule='latest')
cumCoords<-plot.network(windAni)
cumCoords<-layout.normalize(cumCoords)
@

Next, compute a hierarhical tree layout of the transmission tree.
<<windsim7a,fig=TRUE>>=
# calculate coords for transmission tree
treeCoords<-network.layout.animate.Graphviz(windTree,
              layout.par=list(gv.engine='dot',
                              gv.args='-Granksep=3'))
treeCoords<-layout.normalize(treeCoords)
# peek at it
plot(windTree,coord=treeCoords,displaylabels=TRUE,jitter=FALSE)
@

Now lets assemble a dynamic network on \verb@windAni@ using the parts of other networks.

<<windsim8>>=
# FIRST FRAME: all vertices and edges active
activate.vertices(windAni,onset=0,terminus=1)
activate.edges(windAni,onset=0,terminus=1)
# store the plain network coords for cumulative network
activate.vertex.attribute(windAni,'animation.x',cumCoords[,1],
                          onset=0,terminus=Inf)
activate.vertex.attribute(windAni,'animation.y',cumCoords[,2],
                          onset=0,terminus=Inf)

# 2ND FRAME: activate vertices that know and edges that passed it
activate.vertices(windAni,onset=1,terminus=3,
                  v=which(windAni%v%'knowsRumor'))
activate.edges(windAni,onset=1,terminus=3,
               e=which(windAni%e%'passedRumor'))

# THIRD FRAME: transition to tree
activate.vertex.attribute(windAni,'animation.x',treeCoords[,1],
          onset=2,terminus=Inf,v=network.vertex.names(windTree))
activate.vertex.attribute(windAni,'animation.y',treeCoords[,2],
          onset=2,terminus=Inf,v=network.vertex.names(windTree))

# construct slice par to indicate time range to render
windAni%n%'slice.par'<-list(start=0,end=2,interval=1, 
                            aggregate.dur=1,rule='latest')

# render it
saveVideo(
  render.animation(windAni,
            edge.col=function(slice){
              ifelse(!is.na(slice%e%'passedRumor'),
                     'red','#00000055')
            },
            vertex.col=function(slice){
              ifelse(!is.na(slice%v%'knowsRumor'),
                     'red','gray')
            },
            vertex.cex=0.8,label.cex=0.8,label.pos=1,
                   render.cache='none'
  )
, video.name='windsurferTreeTransition.mp4')
@

\noindent\fbox{\parbox{\textwidth}{\textbf{Exercise:} Generate a similar movie, but use the coordinates of the non-hierarchical tree layout (i.e. don't use Graphviz)}}


\section{Tips on loading in data}
\subsection{Can I make a movie if my data is in a set of matrices?}
Yes! We will use the example Harry Potter Support Networks of Goele Bossaert and Nadine Meidert \citep{hpdata}. They have coded the peer support ties between 64 characters appearing in the text of each of the well-known fictional J. K. Rowling novels and made the data available for general use in the form of 6 text formatted adjacency matrices and several attribute files.  You can download and unzip the data files from \url{http://www.stats.ox.ac.uk/~snijders/siena/HarryPotterData.html}, or use the R code below to load in directly from the zip file. 

<<load_zipped_hp_data>>=
# tmp filename for the data
temp_hp.zip <- tempfile() 
download.file("http://www.stats.ox.ac.uk/~snijders/siena/bossaert_meidert_harrypotter.zip",temp_hp.zip)
# read in first matrix file, unziping in the process
hp1 <- read.table(unz(temp_hp.zip, "hpbook1.txt"), 
                  sep=" ",stringsAsFactors=FALSE)
# is it really a matrix?
dim(hp1)
plot(as.network(hp1))
@

Notice the \verb@stringsAsFactors=FALSE@ argument to \verb@read.table@. This prevents the strings from being converted into factors, which then may unexpectedly appears as integers causing all kinds of headaches. Since that seemd to work, lets load in the rest of the files. 
<<load_more_zipped_hp_data>>=
# tmp filename for the data
hp2 <- read.table(unz(temp_hp.zip, "hpbook2.txt"), 
                  sep=" ",stringsAsFactors=FALSE)
hp3 <- read.table(unz(temp_hp.zip, "hpbook3.txt"), 
                  sep=" ",stringsAsFactors=FALSE)
hp4 <- read.table(unz(temp_hp.zip, "hpbook4.txt"), 
                  sep=" ",stringsAsFactors=FALSE)
hp5 <- read.table(unz(temp_hp.zip, "hpbook5.txt"), 
                  sep=" ",stringsAsFactors=FALSE)
hp6 <- read.table(unz(temp_hp.zip, "hpbook6.txt"), 
                  sep=" ",stringsAsFactors=FALSE)
@

To construct a dynamicNetwork, we will arrange them in a list and then convert it.
<<format_hp_data>>=
hpList<-list(hp1,hp2,hp3,hp4,hp5,hp6)

# convert adjacency matrices to networks
hpList<-lapply(hpList,as.network.matrix,matrix.type='adjacency')

# convert list of networks to networkDynamic
harry_potter_support<-networkDynamic(network.list=hpList,)

# read in and assign the names
names<-read.table(unz(temp_hp.zip, "hpnames.txt"),
                  sep="\t",stringsAsFactors=FALSE,header=TRUE)
network.vertex.names(harry_potter_support)<-names$name

# read in and assign the attributes
attributes<-read.table(unz(temp_hp.zip, "hpattributes.txt"),
                       sep="\t",stringsAsFactors=FALSE,header=TRUE)
harry_potter_support%v%'id'<-attributes$id
harry_potter_support%v%'schoolyear'<-attributes$schoolyear
harry_potter_support%v%'gender'<-attributes$gender
harry_potter_support%v%'house'<-attributes$house

# define a net.obs.period
harry_potter_support%n%'net.obs.period'<-list(
  observations=list(c(0,6)),mode="discrete", 
  time.increment=1,time.unit="book volume")

# which vertex is Harry Potter?
which(network.vertex.names(harry_potter_support)=="Harry James Potter")
@

This is going to look like \emph{Harry Potter and the Philosopher's Stone}, right?

<<render_hp,results=hide>>=
render.animation(harry_potter_support)
@

Lets tweak it a bit for some more refinement
<<render_hp,results=hide>>=
compute.animation(harry_potter_support,
                  animation.mode='MDSJ',
                  default.dist=2)
render.animation(harry_potter_support,
            render.par=list(tween.frames=20),
            vertex.cex=0.8,label.cex=0.8,label.col='gray',
            # make shape relate to school year
            vertex.sides=harry_potter_support%v%'schoolyear'-1983,
            # color by gender
            vertex.col=ifelse(harry_potter_support%v%'gender'==1,'blue','green'),
            edge.col="#CCCCCC55"     
)
@

One challenge of constucting movies from matrices is that (as the authors of this dataset note) there is often a great deal of change between network survey panels.


\noindent\fbox{\parbox{\textwidth}{\textbf{Question:} How could dynamic network data (like in the example above) be collected differently to support animations and more flexible analysis of dynamics?}}


\noindent\fbox{\parbox{\textwidth}{\textbf{Exercise:} Choose one of the dynamic dataset (perhaps one from the package networkDynamicData and construct an animation.}}

\section{Misc topics}
\subsection{Compressing video}
\label{sec:compressing}
The saved video output of the animation often produces very large files. These may cause problems for your viewers if you upload them directly to the web.  It is almost always a good idea to compress the video, as a dramatically smaller file can usually be created with little or no loss of quality. Although it may be possible to give \verb@saveVideo()@ various \verb@other.opts@ to control video compression\footnote{The default settings for ffmpeg differ quite a bit depending on platform, some installations may give decent compression without tweaking the settings}, determining the right settings can be a trial and error process. Handbrake \url{http://handbrake.fr/} is an excellent and easy to use tool for doing video compression into the web-standard H.264 codec with appropriate presets.

\subsection{Transparent colors}
Using a bit of transparency can help a lot with readability for many visualizations. It makes it so that overlaping edges can show through and/or be less distracting. Many of the R plot devices support transparency, but specifying the color can be a bit awkward.  The most concise way is to define colors as HTML colorcode hex strings with an alpha channel in the format\verb@"#RRGGBBAA"@. For example, 50\% black is \verb@"#00000088"@, 50\% green would be \verb@"#00FF0088"@.  These can be hard to remember!  It may be easier include an alpha (the computer graphics term for transparency) parameter to the \verb@rgb()@ function, but you still may need to guess the correct proportions of red, green, and blue.  If you want to just make one of R's existing named colors more transparent,  try \verb@grDevices::adjustcolor()@.

<<transparent_colors,fig=TRUE>>=
# 50% blue
rgb(0,0,1,0.5)
# 50% pink
grDevices::adjustcolor('pink',alpha.f=0.5)

# plot example net with 10% green
colorNet<-network.initialize(5)
colorNet[,]<-1
plot(colorNet,edge.lwd=20,edge.col=rgb(0,1,0,0.1))
@


\subsection{How to get help}
Here are some starting points if you reach a dead end:
\begin{itemize}
\item R's built in documentation feature. Each function has a help page, usually with some examples: i.e. \verb@?render.animation@ 
\item The ndtv package vignette (includes much of the material from this workshop): \verb@browseVignettes(package='ndtv')@
\item The statnet wiki has various FAQ pages and resources: \url{https://statnet.csde.washington.edu/trac/wiki}
\item You can always subscribe to the statnet mailing list and post your problem there: \url{https://mailman2.u.washington.edu/mailman/listinfo/statnet_help}
\end{itemize}


\begin{thebibliography}{}

<<foo,include=FALSE,echo=FALSE>>=
packageAsBibitem <- function(pkgname){
  cite <- citation(package=pkgname)
  #for(cite in cites){
    if (length(cite$author)>1){
      au <-paste(format(cite$author[1],include=c('family')),"et al. ")
    } else {
      au <-format(cite$author,include=c('family'))
    }
    cat(paste("\n\\bibitem[",au," (",cite$year,")]{",pkgname,"}\n",sep=''))
    print(cite,style='latex')
    cat("\n\n")
  #}
}
@


\bibitem[MDSJ (2009)]{mdsj}{
Algorithmics Group, University of Konstanz (2009)
\emph{MDSJ: Java Library for Multidimensional Scaling (Version 0.2)}. \url{http://www.inf.uni-konstanz.de/algo/software/mdsj/}. 
}

\bibitem[Almquist et all(2011)]{windsurfers}
Almquist, Zack W. and Butts, Carter T. (2011). ``Logistic Network Regression for Scalable Analysis of Networks with Joint Edge/Vertex Dynamics.'' 
\emph{IMBS Technical Report MBS 11-03}, University of California, Irvine.

\bibitem[Bender-deMoll and McFarland (2006)]{sonia}
Bender-deMoll, Skye and McFarland, Daniel A. (2006) 
\newblock The Art and Science of Dynamic Network Visualization.
\newblock \emph{Journal of Social Structure. Volume 7, Number 2} \url{http://www.cmu.edu/joss/content/articles/volume7/deMollMcFarland/}

\bibitem[Bender-deMoll et al.(2008)]{dynamicNetwork}
Bender-deMoll, S., Morris, M. and Moody, J. (2008)
\newblock Prototype Packages for Managing and Animating Longitudinal Network Data: dynamicnetwork and rSoNIA
\newblock \emph{Journal of Statistical Software} 24:7.

\bibitem[Bossaert, G. and Meidert, N. (2013)]{hpdata}
Bossaert, G. and Meidert, N. (2013) 
\newblock 'We are only as strong as we are united, as weak as we are divided'. A dynamic analysis of the peer support networks in the Harry Potter books. 
\newblock \emph{Open Journal of Applied Sciences}, Vol. 3 No. 2, pp. 174-185.
DOI: \url{http://dx.doi.org/10.4236/ojapps.2013.32024}

\bibitem[Butts(2008)]{network}
Butts CT (2008). 
\newblock network: A Package for Managing Relational Data in R. 
\newblock \emph{Journal of Statistical Software}, 24(2). \url{http://www.jstatsoft.org/v24/i02/}. 


<<echo=False, results=tex, include=True>>=
 packageAsBibitem('networkDynamic')
@

\bibitem[de Leeuw (2009)]{smacof}
de Leeuw J and Mair P (2009).
``Multidimensional Scaling Using Majorization: SMACOF in R.''
\emph{Journal of Statistical Software}, \textbf{31}(3), pp. 1--30.
\url{http://www.jstatsoft.org/v31/i03/}

<<echo=False, results=tex, include=True>>=
 packageAsBibitem('ndtv')
@

\bibitem[John Ellson et al (2001)]{graphviz} 
John Ellson et al (2001) 
\newblock Graphviz -- open source graph drawing tools \emph{Lecture Notes in Computer Science}. Springer-Verlag. p483-484 \url{http://www.graphviz.org}


\bibitem[Handcock et al (2003)]{statnet}
Handcock MS, Hunter DR, Butts CT, Goodreau SM, Morris M (2003b). 
\newblock statnet: Software tools for the Statistical Modeling of Network Data. 
\newblock Statnet Project, Seattle, WA. Version 3,  \url{http://www.statnetproject.org.}


\bibitem[Hunter et al.(2008b)]{ergm}
Hunter DR, Handcock MS, Butts CT, Goodreau SM, Morris M (2008b). 
\newblock ergm: A Package to Fit, Simulate and Diagnose Exponential-Family Models for Networks. 
\newblock \emph{Journal of Statistical Software}, 24(3). \url{http://www.jstatsoft.org/v24/i03/}. 



<<echo=False, results=tex, include=True>>=
 packageAsBibitem('tergm')
@


\bibitem[McFarland (2001)]{mcfarland}
McFarland, Daniel A. (2001) ``Student Resistance: How the Formal and Informal Organization of Classrooms Facilitate Everyday Forms of Student Defiance.'' 
\emph{American Journal of Sociology} \textbf{107} (3): 612-78.


\bibitem[Newcomb(1961)]{newcomb} 
Newcomb T. (1961)
\emph{The acquaintance process} New York: Holt, Reinhard and Winston.

\bibitem[Yihui, Xie   et al.  (2013)]{animation}
Xie Y (2013).
``animation: An R Package for Creating Animations and Demonstrating Statistical Methods.''
\emph{Journal of Statistical Software}, \textbf{53}(1), pp. 1--27.
\url{http://www.jstatsoft.org/v53/i01/}.


\end{thebibliography}

\end{document}
